# Hyper Context 后端接口与数据库设计

本页已对齐当前前端主要页面 packages/frontend/src/views/ProjectEditor.vue 的实际交互与本地 mock 接口，实现口径一致可落地。

## 概览

- 后端框架: Next.js 14 (App Router)
- 数据库: SQLite + Prisma
- 返回约定: 直接返回数据对象/数组，不包裹统一 { code, data } 信封（与前端 axios 拦截器和本地 mocks 对齐）
- API 前缀: `/api`

## 核心领域模型（与前端一致）

- Project 项目：名称、描述、稳定版、MCP 状态、更新时间；knowledgeCount 统计为“文件型节点数量”。
- KnowledgeNode 知识目录树节点：`file | folder` 两类，支持 parentId + 排序；文件型节点才有内容。
- Version 版本：`draft | published` 两态；发布后可被标记为稳定版（stable）。
- VersionContent 版本内容：每个版本保存一份 main（项目级 Markdown）与每个文件节点的结构化正文（XML-like 片段）。
- VersionTreeSnapshot 版本快照：发布时冻结目录树快照；draft 版本读取当前工作树。

## 数据库设计

SQLite（Prisma）落库建议如下，兼顾查询与快照能力。

### 1) 项目表 projects（基本保持不变）
```sql
CREATE TABLE projects (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  stable_version_id TEXT,
  mcp_status TEXT CHECK(mcp_status IN ('active','inactive','error')) DEFAULT 'inactive',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  deleted_at DATETIME NULL,

  FOREIGN KEY (stable_version_id) REFERENCES versions(id)
);
CREATE INDEX idx_projects_name ON projects(name);
CREATE INDEX idx_projects_updated_at ON projects(updated_at);
```

### 2) 知识目录树 knowledge_nodes（替代原 knowledge/knowledge_extends）
```sql
CREATE TABLE knowledge_nodes (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  name TEXT NOT NULL,
  type TEXT CHECK(type IN ('file','folder')) NOT NULL,
  parent_id TEXT NULL,
  sort_order INTEGER NOT NULL DEFAULT 0,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_id) REFERENCES knowledge_nodes(id) ON DELETE CASCADE
);
CREATE INDEX idx_kn_project ON knowledge_nodes(project_id);
CREATE INDEX idx_kn_parent ON knowledge_nodes(parent_id);
CREATE INDEX idx_kn_sort ON knowledge_nodes(parent_id, sort_order);
```

说明：
- 不再将“核心/扩展”等语义做成子表；文件节点的结构化正文以 XML-like 文本存储在版本内容中（见下）。
- 目录树的重命名/移动通过更新 `name/parent_id/sort_order` 完成，禁止把某节点移动到其子树中。

### 3) 版本表 versions（新增 status/notes/tree 快照）
```sql
CREATE TABLE versions (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  version TEXT NOT NULL,
  status TEXT CHECK(status IN ('draft','published')) NOT NULL DEFAULT 'draft',
  is_stable INTEGER NOT NULL DEFAULT 0,
  notes TEXT,
  tree_snapshot JSON NULL, -- 发布时冻结的目录树（draft 为 NULL）
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX uk_versions_proj_ver ON versions(project_id, version);
CREATE INDEX idx_versions_proj ON versions(project_id);
CREATE INDEX idx_versions_stable ON versions(project_id, is_stable);
```

### 4) 版本内容 version_contents（main + 每文件正文）
```sql
CREATE TABLE version_contents (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  version_id TEXT NOT NULL,
  main TEXT NOT NULL DEFAULT '',

  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  FOREIGN KEY (version_id) REFERENCES versions(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX uk_vc_version ON version_contents(version_id);

CREATE TABLE node_contents (
  version_id TEXT NOT NULL,
  node_id TEXT NOT NULL,
  content TEXT NOT NULL DEFAULT '', -- 结构化文本：<head/><extend/>

  PRIMARY KEY (version_id, node_id),
  FOREIGN KEY (version_id) REFERENCES versions(id) ON DELETE CASCADE,
  FOREIGN KEY (node_id) REFERENCES knowledge_nodes(id) ON DELETE CASCADE
);
```

说明：
- 与前端 mock 完全对应：每个版本 1 条 main，若干条 nodeId->content 映射。
- 发布后内容只读；草稿可更新。

### 5) 其他表

- mcp_configs 与 system_configs 延用原设计，不再赘述。

## Prisma Schema（对齐上表与前端模型）

```prisma
// prisma/schema.prisma
generator client { provider = "prisma-client-js" }
datasource db { provider = "sqlite"; url = "file:./dev.db" }

model Project {
  id              String   @id @default(cuid())
  name            String
  description     String?
  stableVersionId String?  @map("stable_version_id")
  mcpStatus       McpStatus @default(inactive) @map("mcp_status")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")
  deletedAt       DateTime? @map("deleted_at")

  nodes        KnowledgeNode[]
  versions     Version[]
  mcpConfigs   McpConfig[]
  stableVersion Version? @relation("StableVersion", fields: [stableVersionId], references: [id])

  @@map("projects")
}

model KnowledgeNode {
  id        String  @id @default(cuid())
  projectId String  @map("project_id")
  name      String
  type      NodeType
  parentId  String? @map("parent_id")
  sortOrder Int     @default(0) @map("sort_order")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  project  Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parent   KnowledgeNode? @relation("NodeHierarchy", fields: [parentId], references: [id])
  children KnowledgeNode[] @relation("NodeHierarchy")
  nodeContents NodeContent[]

  @@map("knowledge_nodes")
}

model Version {
  id         String   @id @default(cuid())
  projectId  String   @map("project_id")
  version    String
  status     VersionStatus @default(draft)
  isStable   Boolean  @default(false) @map("is_stable")
  notes      String?
  treeSnapshot Json?  @map("tree_snapshot")
  createdAt  DateTime @default(now()) @map("created_at")

  project        Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  stableProjects Project[] @relation("StableVersion")
  content        VersionContent?
  nodeContents   NodeContent[]

  @@unique([projectId, version])
  @@map("versions")
}

model VersionContent {
  id         String  @id @default(cuid())
  projectId  String  @map("project_id")
  versionId  String  @unique @map("version_id")
  main       String  @default("")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  version Version @relation(fields: [versionId], references: [id], onDelete: Cascade)

  @@map("version_contents")
}

model NodeContent {
  versionId String @map("version_id")
  nodeId    String @map("node_id")
  content   String @default("")

  version Version       @relation(fields: [versionId], references: [id], onDelete: Cascade)
  node    KnowledgeNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)

  @@id([versionId, nodeId])
  @@map("node_contents")
}

model McpConfig {
  id           String   @id @default(cuid())
  projectId    String   @map("project_id")
  name         String
  description  String?
  config       Json
  isActive     Boolean  @default(true) @map("is_active")
  lastTestedAt DateTime? @map("last_tested_at")
  testResult   Json?    @map("test_result")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, name])
  @@map("mcp_configs")
}

model SystemConfig {
  id          String   @id @default(cuid())
  key         String   @unique
  value       Json?
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("system_configs")
}

enum McpStatus { active inactive error }
enum NodeType { file folder }
enum VersionStatus { draft published }
```

## RESTful API（与前端 mock 对齐）

说明：所有接口返回直接为数据对象或数组；错误使用 `{ message }`，HTTP 状态码表意清晰。

### 项目 Project
- `GET /api/projects` → `Project[]`
- `GET /api/projects/:id` → `Project`
- `POST /api/projects` { name, description? } → `Project`
- `PUT /api/projects/:id` Partial<Project> → `Project`
- `DELETE /api/projects/:id` → 204

Project 结构（前端 types 对齐）：
```ts
type Project = {
  id: string
  name: string
  description: string
  knowledgeCount: number   // 按文件节点计数
  stableVersion: string    // 若无稳定版，请返回 '—'（与 Dashboard 显示一致）
  mcpStatus: 'active'|'inactive'|'error'
  updatedAt: string        // ISO
}
```

### 知识目录树 Knowledge
- `GET /api/projects/:id/knowledge/tree` → `KnowledgeNode[]`
- `POST /api/projects/:id/knowledge/nodes` { parentId?, name, type } → `KnowledgeNode`
- `PATCH /api/projects/:id/knowledge/nodes/:nodeId` { name? } → `KnowledgeNode`
- `DELETE /api/projects/:id/knowledge/nodes/:nodeId` → 204
- 移动（保持排序）：
  - `POST /api/projects/:id/knowledge/nodes/:nodeId/move` { targetParentId, beforeId? } → 204
  - `POST /api/projects/:id/versions/:vid/knowledge/nodes/:nodeId/move` { targetParentId, beforeId? } → 204（仅允许 draft）

约束：
- 不允许把节点移动到其自身子树内；`beforeId` 为空则插入到目标父节点末尾。

前端节点结构：
```ts
type KnowledgeNode = { id: string; name: string; type: 'file'|'folder'; parentId?: string|null; children?: KnowledgeNode[] }
```

### 版本 Version
- `GET /api/projects/:id/versions` → `Version[]`
- `GET /api/projects/:id/versions/:vid` → `Version`
- `POST /api/projects/:id/versions` { version?, notes? } → `Version`（默认 draft）
- `POST /api/projects/:id/versions/:vid/publish` → `Version`（置为 published，并冻结 `tree_snapshot`）
- `POST /api/projects/:id/versions/:vid/stable` → 200（仅允许 published 版本标记为稳定，且唯一）
- `GET /api/projects/:id/versions/stable` → `Version`（当前稳定版，不存在则 404）

Version 结构（前端 types 对齐）：
```ts
type Version = { id: string; version: string; isStable?: boolean; createdAt: string; notes?: string; status?: 'draft'|'published' }
```

### 版本内容与快照 Content/Snapshot
- 快照（树 + 内容合集）：
  - `GET /api/projects/:id/versions/:vid/snapshot?rootId=:nodeId` →
    ```ts
    type VersionSnapshot = {
      version: Version
      tree: KnowledgeNode[]          // published 用冻结树；draft 用当前工作树
      contents: { main: string; nodes: Record<string,string> } // 仅返本次 tree 涵盖的文件
    }
    ```
  - `GET /api/projects/:id/versions/stable/snapshot` → `VersionSnapshot`（稳定版）

- 主文档 main：
  - `GET /api/projects/:id/versions/:vid/knowledge/main` → { content: string }
  - `PUT /api/projects/:id/versions/:vid/knowledge/main` { content } → { content }（仅 draft）

- 文件内容 nodes：
  - `GET /api/projects/:id/versions/:vid/knowledge/nodes/:nodeId/content` → { content }
  - `PUT /api/projects/:id/versions/:vid/knowledge/nodes/:nodeId/content` { content } → { content }（仅 draft）

- 稳定版便捷读取：
  - `GET /api/projects/:id/versions/stable/knowledge/main` → { content }
  - `GET /api/projects/:id/versions/stable/knowledge/nodes/:nodeId/content` → { content }

内容格式说明：
- main：任意 Markdown 文本。
- 节点内容：结构化 XML-like 文本（被编辑器解析/生成），形如：
  ```xml
  <head>
    <name>介绍.md</name>
    <level>core</level>
    <description>项目概览…</description>
  </head>
  <extend>
    <block>
      <name>术语表</name>
      <level>extend</level>
      <description>核心术语释义</description>
      <content>…Markdown…</content>
    </block>
  </extend>
  ```

## 关键业务语义（与页面一致）

- 可编辑性：仅 `status=draft` 的版本允许创建/重命名/删除/移动节点以及更新 main/节点内容；`published` 只读。
- 发布 publish：将 draft 置为 published，同时把当时的项目目录树冻结到 `versions.tree_snapshot`；内容保留在 `version_contents/node_contents` 中。
- 稳定版 stable：只能把 published 版本标记为稳定，且一个项目最多一个稳定版；前端右侧栏“版本”区域对应 `POST /versions/:vid/stable` 操作。
- 快照读取：前端切换版本时调用 `GET /versions/:vid/snapshot` 一次拿到树 + 该树覆盖范围内的内容映射；`rootId` 可按子树裁剪。

## 与前端/Mock 的一一对应

- packages/frontend/src/api/endpoints.ts 中已定义：
  - 项目：`/projects`、`/projects/:id`
  - 知识树：`/projects/:id/knowledge/tree`、`/knowledge/nodes` 系列、`/knowledge/nodes/:id/move`（含版本态）
  - 版本：`/projects/:id/versions` 列表/创建、`/versions/:vid/stable`、`/versions/:vid/publish`、`/versions/:vid/snapshot`
- packages/frontend/mock/* 提供了同名路由的开发期模拟实现，真实后端需保持同样的路径与负载结构。

## Dashboard 对齐说明（无缺口约定）

- 项目列表 GET /api/projects：
  - 返回完整列表（暂不做服务端分页/搜索）；前端本地过滤关键字。
  - 排序：按 `updatedAt` 降序。
  - `stableVersion`：若项目暂无稳定版，直接返回字符串 `'—'`，避免前端出现 `vundefined`。
  - `knowledgeCount`：以“当前工作树中文件型节点数”为口径，不含文件夹。
- MCP 状态徽标：前端基于 `mcpStatus` 渲染状态点与标签；建议色值映射
  - `active` → 绿色；`inactive` → 灰色；`error` → 红色。
- 更新时间 `updatedAt` 更新时机：以下任一写操作成功后应刷新项目 `updatedAt`
  - 知识树节点：创建/重命名/删除/移动
  - 内容：PUT main、PUT 节点内容
  - 版本：创建、发布、标记稳定

## 后续扩展建议

- 权限与审计：为节点操作与版本发布引入审计表（actor、action、payload、at）。
- 全文检索：为 node_contents.content 建立倒排索引或外挂搜索引擎。
- 差异对比：为版本间 main/节点内容做差异计算接口，辅助发布评审。
